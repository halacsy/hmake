import Data.List.Split

type Command = String
type File = String

type Name = String
data Value = SValue String | IValue Int deriving (Show)
data Param = Param Name Value deriving (Show)
type Params = [Param]
type FileGen = Params->File
type FileListGen = Params->[File]
type CommandGen = Params->Command

-- 

data ParametricRule = ParametricRule CommandGen FileListGen FileGen
data Rule = Rule Command [File] File deriving (Show)
data Tree =  Node Rule [Tree] | Term deriving (Show)

-- if f1 is newer than f2 then we need to regenarete f2
triggers::File->File->Bool
triggers  "a-2012" "b-2012" = True 
triggers _ _ = False


generates::File->Rule->Bool
generates f (Rule cmd ins out) = out == f

rules_to_tree::[Rule]->File->Tree
rules_to_tree g f =
    case filter (generates f) g of
        [] -> Term
        [r@(Rule _ inputs _)] -> Node r (map (rules_to_tree g) inputs)
        _ -> error (f ++ " is generated by >1 rules")

should_be_rerun (Rule _ inputs output) =
    or (map (\file -> triggers file output) inputs)



-- selects subtree which should be executed
select::Tree->Tree
select Term = Term
select (Node r childs) = -- this must be executed if any of it's child
                let ct = filter is_not_term (map select childs) in
                if (null ct) && not (should_be_rerun r) then
                    Term
                else 
                    (Node r ct)
                where
                -- maybe there is a shorter version of this
                is_not_term Term = False
                is_not_term _ = True 

flatten :: [[a]] -> [a]
flatten l = foldl (++) [] l

execution::Tree->[Rule]
execution Term = []
execution (Node r childs) = (flatten (map execution childs)) ++ [r]

-- let's build a parametric RuleSet
-- sort a-$date > b-$date
-- sort c > d
-- paste b-$date d > e-$date
conts x _ = x

get_value::Params->Name->Value
get_value params n =
    case filter (\(Param n' _) -> n' == n) params of
        [] -> error "not found"
        (Param _ v):xs ->v

to_string::Value->String
to_string (SValue v) = v
to_string (IValue v) = show v


create_string_template::String->(Params->String)
create_string_template s = 
    -- this is a temporal solution, we just check the end of the string
    case splitOn "$" s of
        [] -> error "empty string"
        [s] -> const s
        n:p:[] -> \params -> n++(to_string (get_value params p))

join_templates::[Params->String]->(Params->[String])
join_templates l = \params -> (map (\template -> template params) l)

parse_string_list::[String]->FileListGen
parse_string_list l = join_templates $ map create_string_template l

anchor_parameter::Params->ParametricRule->Rule
anchor_parameter params (ParametricRule command_gen file_list_gen file_gen) =
        (Rule (command_gen params) (file_list_gen params) (file_gen params))




my_template = create_string_template "a-$date"


mypr = [ParametricRule (conts "sort") (parse_string_list ["a-$date"]) (create_string_template "b-$date"),
        ParametricRule (conts "sort") (parse_string_list ["c"]) (create_string_template "d"),
        ParametricRule (conts "paste") (parse_string_list ["b-$date", "d"]) (create_string_template "e-$date")]
params = [(Param "date" (SValue "2012"))]
myg = (map (anchor_parameter params) mypr)

main = do

    print (rules_to_tree myg "e-2012")
    print (select $ rules_to_tree myg "e-2012")
    print (execution $ select $ rules_to_tree myg "e-2012")
