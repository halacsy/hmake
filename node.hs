type Command = String
type File = String
-- 
data Rule = Rule Command [File] File deriving (Show)
data Tree =  Node Rule [Tree] | Term deriving (Show)

-- if f1 is newer than f2 then we need to regenarete f2
triggers::File->File->Bool
triggers  "a" "b" = True 
triggers _ _ = False


generates::File->Rule->Bool
generates f (Rule cmd ins out) = out == f

rules_to_tree::[Rule]->File->Tree
rules_to_tree g f =
    case filter (generates f) g of
        [] -> Term
        [r@(Rule _ inputs _)] -> Node r (map (rules_to_tree g) inputs)
        _ -> error (f ++ " is generated by >1 rules")

should_be_rerun (Rule _ inputs output) =
    or (map (\file -> triggers file output) inputs)



-- selects subtree which should be executed
select::Tree->Tree
select Term = Term
select (Node r childs) = -- this must be executed if any of it's child
                let ct = filter is_not_term (map select childs) in
                if (null ct) && not (should_be_rerun r) then
                    Term
                else 
                    (Node r ct)
                where
                -- maybe there is a shorter version of this
                is_not_term Term = False
                is_not_term _ = True 

flatten :: [[a]] -> [a]
flatten l = foldl (++) [] l

execution::Tree->[Rule]
execution Term = []
execution (Node r childs) = (flatten (map execution childs)) ++ [r]

myg = [(Rule "sort" ["a"] "b"), (Rule "sort" ["c"] "d"), (Rule "paste" ["b", "d"] "e")]
main = do
    print (rules_to_tree myg "e")
    print (execution $ select $ rules_to_tree myg "e")
