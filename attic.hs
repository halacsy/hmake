generates::File->Rule->Bool
generates f (Rule cmd ins out) = out == f

flatten :: [[a]] -> [a]
flatten l = foldl (++) [] l

direct_generator_files g f =
	case filter (generates f) g of
		[] -> []
		[(Rule _ inputs _)] -> inputs
		_ -> error (f ++ " is generated by >1 rules")

generator_files::G -> File -> [File]
generator_files g f =
	d ++ (flatten $ map (generator_files g) $ d) where
		d = direct_generator_files g f




		create_template::String->(Params->String)
string_template s = 
    -- this is a temporal solution, we just check the end of the string
    case splitOn "$" s of
        [] -> error "empty string"
        [s] -> const s
        n:p:[] -> \params -> n++(get_value params p)

params = [(Param "date" (SValue "2012"))]


a = File {name ="a", pnames=["date"], anchored_parameters=[]}
b = File {name ="b", pnames=["date"], anchored_parameters=[]}
b1 = File {name ="b", pnames=["date"], anchored_parameters=[("date", "1")]}
b2 = File {name ="b", pnames=["date"], anchored_parameters=[("date", "2")]}

c = File {name ="c", pnames=[], anchored_parameters=[]}
d = File {name ="d", pnames=[], anchored_parameters=[]}
e = File {name ="e", pnames=[], anchored_parameters=[]}

r1 = Rule {cmd="sort", inputs=[a], output=b}
r2 = Rule {cmd="sort", inputs=[c], output=d}
r3 = Rule {cmd="paste", inputs=[b1, b2, d], output=e}

p = File {name="vacak", pnames=["date"], anchored_parameters=[]}
target = e

rules = [r1, r2, r3]
main = do
	print (get_anchored (anchored_parameters b1) ["date"])
	print r3
	print (execution $ select $ rules_to_tree rules target)

type OnlyFile = File 

cat::File->OnlyFile
cat f = f

type WithoutOutput = (File, String)
(||)::OnlyFile->String->WithoutOutput
(||) f c = (f, c)

(>)::WithoutOutput->File->Rule
(>) (input, cmd) output =  (Rule output (\params -> ([substitute input params] , cmd)))




funnel file oparam function iparam cmd =
    \params ->
        ((map (\v -> substitute file (params##(oparam, v)))) (function (params#iparam)) , cmd)

-- cat input[input_param=generate(output_param)] | cmd > output(output_param)
funnel_rule what from_what output_param generate input_param cmd =
    (Rule what ( funnel  from_what output_param generate input_param cmd))

parse_output str = 
    let (f, _, _) = fp str in f

days_of_month::String->[String]
days_of_month y  =  map show [1..5]

cmd = "cat"
(input_template, running_param, (Expr fname params)) = fp "daily_uniq_users-$year=2012-$month=01-$day=(day_of_month $month)" 
p = head params
output = (parse_output "monthly-$year-$month")
func = days_of_month

r = funnel_rule output input_template running_param func p cmd

rule:: Q Exp
rule = 

    do
    return $ AppE (AppE (AppE (AppE (AppE (AppE (VarE (mkName "funnel_rule")) (VarE (mkName "output"))) (VarE (mkName "input_template"))) (VarE $ mkName "running_param")) (VarE $ mkName funname )) (VarE $ mkName "p")) (VarE $ mkName "cmd")




match2::[Chunk]->String->Params->String
match2 chunks name params = foldl (++) "" (map chunk_to_string chunks) where
	chunk_to_string (K k) = case Map.lookup k params of
    							  		Nothing -> error ("can't find " ++ k ++ " in " ++ (show params) ++ " for file " ++ name) 
    							  		Just v -> v
    	chunk_to_string (Part p) = p
    	chunk_to_string (KV k v) = v
        chunk_to_string (KF k e) = k

-- returns a \p -> fun_name p function


fp::String->(File, String, Expr)
fp s = 
	-- this should be shorted
    let chunks = case parseFileName s  of
            (Left err) -> error (show err)
            (Right r) -> r
    in
    let collectParam chunk = case chunk of 
                        K k -> Just k
                        KV k _ -> Just k
                        KF k _ -> Just k
                        _ -> Nothing in
    -- nub == sort | uniq 
    let params = nub $ mapMaybe collectParam chunks in

    let collectKVs chunk = case chunk of
                        KV k v -> Just (k,v)
                        _ -> Nothing in
    let kvs = nub $ mapMaybe collectKVs chunks in

    let collectNames chunk = case chunk of
                        Part s -> Just s
                        _ -> Nothing in
    let name = foldl (++) "" (mapMaybe collectNames chunks) in
    -- TODO, eliminate heads
    let collectKFs chunk = case chunk of
                        KF name expr -> Just (name, expr)
                        _ -> Nothing in
    let (fname, pexpr) = head $ mapMaybe collectKFs chunks in

    let file_name_generator = let chunks' = map (\c -> case c of 
                                                    KF name _ -> K name 
                                                    x -> x) chunks in
         match2 chunks' name 
    in
    (create_file name file_name_generator  params (params_from_list kvs), fname, pexpr)
   




chain =  select 12 Eq "show_kpi" ->> cut [9] ->> select 1 LtE "1300000" ->> freq 1 ->> select 2 Eq 1 ->> cut [1]
x = chain $ load "VACAK"

main = do 
    putStrLn (pig_print x)
